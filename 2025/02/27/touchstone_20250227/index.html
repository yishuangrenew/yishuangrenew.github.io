<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>touchstone_2025/02/27 | 趁年轻</title><meta name="author" content="C x l"><meta name="copyright" content="C x l"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=":whale:touchstone_2025&#x2F;02&#x2F;27 时间：2025年2月27日01:05:53  -&gt; 2025年2月27日01:45:02 ok 1.介绍操作系统的存储管理答：操作系统的存储管理负责高效分配和利用内存资源，确保进程安全运行，并通过虚拟化技术扩展可用内存。以下是其核心要点： 1.核心功能  内存分配与回收动态分配连续或非连续内存空间（如分页）给进程，"><meta property="og:type" content="article"><meta property="og:title" content="touchstone_2025&#x2F;02&#x2F;27"><meta property="og:url" content="https://yishuangrenew.github.io/2025/02/27/touchstone_20250227/index.html"><meta property="og:site_name" content="趁年轻"><meta property="og:description" content=":whale:touchstone_2025&#x2F;02&#x2F;27 时间：2025年2月27日01:05:53  -&gt; 2025年2月27日01:45:02 ok 1.介绍操作系统的存储管理答：操作系统的存储管理负责高效分配和利用内存资源，确保进程安全运行，并通过虚拟化技术扩展可用内存。以下是其核心要点： 1.核心功能  内存分配与回收动态分配连续或非连续内存空间（如分页）给进程，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yishuangrenew.github.io/img/avatar.png"><meta property="article:published_time" content="2025-02-26T16:00:00.000Z"><meta property="article:modified_time" content="2025-02-26T17:59:54.125Z"><meta property="article:author" content="C x l"><meta property="article:tag" content="考研复试"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://yishuangrenew.github.io/img/avatar.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "touchstone_2025/02/27",
  "url": "https://yishuangrenew.github.io/2025/02/27/touchstone_20250227/",
  "image": "https://yishuangrenew.github.io/img/avatar.png",
  "datePublished": "2025-02-26T16:00:00.000Z",
  "dateModified": "2025-02-26T17:59:54.125Z",
  "author": [
    {
      "@type": "Person",
      "name": "C x l",
      "url": "https://yishuangrenew.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon_my.ico"><link rel="canonical" href="https://yishuangrenew.github.io/2025/02/27/touchstone_20250227/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>(() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: '[object Object]',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"touchstone_2025/02/27",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/default_top_img.png)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/nav_logo.png" alt="Logo"><span class="site-name">趁年轻</span></a><a class="nav-page-title" href="/"><span class="site-name">touchstone_2025/02/27</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">touchstone_2025/02/27</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-26T16:00:00.000Z" title="发表于 2025-02-27 00:00:00">2025-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-26T17:59:54.125Z" title="更新于 2025-02-27 01:59:54">2025-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/touchstone/">touchstone</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><strong>:whale:touchstone_2025&#x2F;02&#x2F;27</strong></p><p>时间：2025年2月27日01:05:53 -&gt; 2025年2月27日01:45:02 ok</p><h1 id="1-介绍操作系统的存储管理"><a href="#1-介绍操作系统的存储管理" class="headerlink" title="1.介绍操作系统的存储管理"></a>1.介绍操作系统的存储管理</h1><p>答：操作系统的<strong>存储管理</strong>负责<strong>高效分配和利用内存资源</strong>，确保进程安全运行，并通过<strong>虚拟化技术</strong>扩展可用内存。以下是其核心要点：</p><p><strong>1.核心功能</strong></p><ul><li><strong>内存分配与回收</strong><br>动态分配连续或非连续内存空间（如分页）给进程，回收释放的资源以供复用。</li><li><strong>地址转换</strong><br>将进程的<strong>逻辑地址</strong>转换为物理地址，通过<strong>页表&#x2F;段表</strong>实现，硬件支持如MMU（内存管理单元）和TLB（快表）加速转换。</li><li><strong>内存保护</strong><br>利用<strong>界限寄存器</strong>或<strong>页表权限位</strong>（如读&#x2F;写&#x2F;执行）隔离进程，防止非法访问。</li><li><strong>虚拟内存</strong><br>允许进程使用超出物理内存的逻辑空间，通过页面置换（如LRU算法）按需调入&#x2F;调出数据。</li></ul><p><strong>2.关键技术</strong></p><ul><li><strong>分页管理</strong><ul><li>内存划分为固定大小的<strong>页框</strong>，进程划分为同等大小的<strong>页</strong>。</li><li><strong>页表</strong>维护页号到页框号的映射，解决外部碎片问题，但存在内部碎片（如最后一页未填满）。</li><li><strong>多级页表</strong>节省空间（如Linux四级页表），<strong>TLB</strong>缓存高频页表项，减少访问延迟。</li></ul></li><li><strong>分段管理</strong><ul><li>按逻辑模块（代码、数据、堆栈等）划分内存，每段独立分配，支持动态扩展和共享（如共享库）。</li><li><strong>段表</strong>记录段基址和长度，需硬件支持地址检查，易产生外部碎片。</li></ul></li><li><strong>段页式结合</strong><br>先分段再分页（如Intel x86架构），兼顾逻辑清晰与内存利用率。</li><li><strong>虚拟内存</strong><ul><li><strong>请求分页</strong>：仅加载必要页到内存，缺页时触发中断从磁盘调入。</li><li>页面置换算法：<ul><li><strong>OPT</strong>：淘汰未来最久不用的页（理论最优，不可实现）。</li><li><strong>FIFO</strong>：可能引发Belady异常（增加页框反而缺页增多）。</li><li><strong>LRU</strong>：基于最近使用时间，近似实现如Clock算法。</li></ul></li><li><strong>抖动处理</strong>：通过调整并发进程数或工作集模型避免频繁置换。</li></ul></li></ul><p><strong>3.碎片问题</strong></p><ul><li><strong>内部碎片</strong>：分配单元未完全利用（如分页中最后一页未满），可接受但需权衡页大小。</li><li><strong>外部碎片</strong>：空闲内存分散无法满足大请求（如可变分区），通过<strong>紧凑技术</strong>或分页&#x2F;分段解决。</li></ul><p><strong>4. 实际应用</strong></p><ul><li>Linux内存管理：<ul><li>使用<strong>伙伴系统</strong>分配物理页框，解决外部碎片。</li><li><strong>Swap分区</strong>作为虚拟内存扩展，采用LRU近似算法（二次机会法）置换页面。</li></ul></li><li><strong>Windows系统</strong>：支持动态调整页面文件大小（pagefile.sys），按需分配虚拟内存。</li></ul><p><strong>总结</strong></p><p>​	存储管理通过分页、分段、虚拟化等技术，平衡效率与安全，最大化内存利用率。理解其原理对优化程序性能（如减少缺页中断）和系统调优（如避免抖动）至关重要。</p><h1 id="2-MYSQL和redis的应用场景"><a href="#2-MYSQL和redis的应用场景" class="headerlink" title="2.MYSQL和redis的应用场景"></a>2.MYSQL和redis的应用场景</h1><p>答：MySQL 和 Redis 是两种截然不同的数据库系统，分别适用于不同场景。以下是它们的核心应用场景及对比：</p><hr><p><strong>一、MySQL 的应用场景</strong></p><p>​	MySQL 是<strong>关系型数据库</strong>，基于磁盘存储，支持复杂查询和事务处理，适用于需要持久化、结构化数据存储的场景：</p><ol><li>Web 应用与 CMS 系统<ul><li>存储用户信息、文章内容、产品数据等结构化数据，支持高并发读写（如 WordPress、Django 等框架）。</li></ul></li><li>电子商务与订单管理<ul><li>管理商品信息、订单详情、库存数据，支持事务处理（如 Magento、WooCommerce）。</li></ul></li><li>企业级应用（ERP&#x2F;CRM）<ul><li>处理财务数据、客户关系、供应链管理等复杂业务逻辑，支持多表关联查询。</li></ul></li><li>数据分析与报表<ul><li>通过 SQL 聚合函数和复杂查询生成业务报表，支持数据仓库整合。</li></ul></li><li>金融与合规场景<ul><li>存储交易记录、账户信息，支持 ACID 事务确保数据一致性（如银行系统）。</li></ul></li></ol><p><strong>优势</strong>：</p><ul><li>成熟的事务支持（ACID）。</li><li>数据持久化，适合长期存储。</li><li>复杂查询能力（JOIN、子查询等）。</li></ul><hr><p><strong>二、Redis 的应用场景</strong></p><p>​	Redis 是<strong>内存数据库</strong>，基于键值存储，支持丰富数据结构和高并发读写，适用于需要快速响应和实时处理的场景：</p><ol><li>缓存加速<ul><li>缓存热点数据（如用户会话、商品详情），减轻 MySQL 负载，提高响应速度。</li></ul></li><li>会话存储（Session Cache）<ul><li>分布式系统中共享用户会话状态，支持无状态服务架构。</li></ul></li><li>实时排行榜与计数器<ul><li>使用有序集合（ZSET）实现实时排名（如游戏积分、电商销量榜）。</li><li>原子操作（INCR）统计点赞数、页面访问量。</li></ul></li><li>消息队列与异步任务<ul><li>通过 List 或 Stream 实现轻量级消息队列（如订单异步处理）。</li></ul></li><li>分布式锁与限流<ul><li>使用 SETNX 命令实现分布式锁，控制资源并发访问。</li><li>限制 API 调用频率（如 IP 访问限流）。</li></ul></li><li>实时数据处理<ul><li>存储 IoT 设备数据、社交动态，支持快速读写（如实时在线用户统计）。</li></ul></li></ol><p><strong>优势</strong>：</p><ul><li>毫秒级读写性能。</li><li>支持多种数据结构（String、Hash、List、Set、ZSet 等）。</li><li>高并发处理能力（单机 10万+ QPS）。</li></ul><hr><p><strong>三、对比与选型建议</strong></p><table><thead><tr><th><strong>维度</strong></th><th><strong>MySQL</strong></th><th><strong>Redis</strong></th></tr></thead><tbody><tr><td><strong>数据模型</strong></td><td>结构化数据（表、行、列）</td><td>非结构化数据（键值对、多种数据结构）</td></tr><tr><td><strong>存储介质</strong></td><td>磁盘（持久化）</td><td>内存（可配置持久化到磁盘）</td></tr><tr><td><strong>查询能力</strong></td><td>复杂 SQL 查询</td><td>简单键值操作，无 JOIN 能力</td></tr><tr><td><strong>适用场景</strong></td><td>持久化存储、事务处理、复杂分析</td><td>缓存、实时计算、高并发读写</td></tr><tr><td><strong>性能瓶颈</strong></td><td>磁盘 I&#x2F;O</td><td>内存容量与网络带宽</td></tr></tbody></table><p><strong>协作模式</strong>：</p><ul><li>典型组合：Redis 作为 MySQL 的缓存层，高频读请求由 Redis 处理，低频或复杂写请求由 MySQL 处理。</li><li>互补场景：Redis 处理实时数据（如库存扣减），MySQL 存储最终一致性数据。</li></ul><hr><p><strong>四、总结</strong></p><ul><li><strong>优先选择 MySQL</strong>：需事务支持、复杂查询、长期数据存储的场景（如金融系统、企业 ERP）。</li><li><strong>优先选择 Redis</strong>：需高性能、实时处理、高并发的场景（如缓存、排行榜、消息队列）。</li><li>结合使用：多数互联网应用采用MySQL + Redis架构，兼顾性能与数据可靠性。</li></ul><h1 id="3-操作系统的特征"><a href="#3-操作系统的特征" class="headerlink" title="3.操作系统的特征"></a>3.操作系统的特征</h1><p>答：操作系统的核心特征可概括为 <strong>并发、共享、虚拟、异步</strong>，其中<strong>并发和共享</strong>是基础特征，二者互为存在条件 。以下详细解析各特征及其相互关系：</p><hr><p><strong>1. 并发（Concurrency）</strong></p><ul><li>定义：指多个事件在<strong>同一时间间隔内</strong>发生，宏观上表现为“同时运行”，微观上通过分时调度实现交替执行。<ul><li>与并行的区别：并行是多个事件在同一时刻真正同时执行，依赖多核或多处理器硬件支持。</li></ul></li><li>实现意义：<ul><li>单核CPU通过时间片轮转实现多任务并发（如同时运行浏览器和音乐播放器）；</li><li>多核CPU支持并行执行，但仍需并发性管理超出核心数的任务。</li></ul></li><li>应用场景：多道程序运行、用户与系统交互（如分时操作系统）。</li></ul><hr><p><strong>2. 共享（Sharing）</strong></p><ul><li>定义：系统中的资源（如CPU、内存、设备）可供多个并发进程共同使用。</li><li>共享方式：<ul><li>互斥共享：资源在某一时段仅允许一个进程访问（如摄像头、打印机）。</li><li>同时共享：资源可被多个进程“宏观同时”使用，微观上交替访问（如硬盘读写、内存分时复用）。</li></ul></li><li>与并发的关系：<ul><li>若没有并发，共享失去意义（单进程独占资源）；</li><li>若没有共享，并发无法实现（进程因资源竞争无法运行）。</li></ul></li></ul><hr><p><strong>3. 虚拟（Virtualization）</strong></p><ul><li>定义：通过技术手段将物理资源抽象为逻辑上的多份资源，提升资源利用率。</li><li>实现形式：<ul><li>虚拟处理器：单核CPU通过时间片轮转模拟多核并行（如同时运行多个程序）。</li><li>虚拟存储器：物理内存+磁盘交换区扩展为更大的逻辑内存空间（如程序使用4GB内存，实际物理内存仅2GB）。</li><li>虚拟设备：如虚拟网络接口、虚拟磁盘分区。</li></ul></li><li>关键技术：<ul><li>时分复用（如CPU时间片）和空分复用（如内存分页）。</li></ul></li></ul><hr><p><strong>4. 异步（Asynchronism）</strong></p><ul><li>定义：进程因资源竞争导致执行顺序和速度不可预知，表现为“走走停停”。</li><li>原因：<ul><li>多进程并发时，资源分配动态变化（如I&#x2F;O操作等待、时间片耗尽）；</li><li>单进程若独占资源（无并发），则执行会“一贯到底”。</li></ul></li><li>影响：需通过同步机制（如信号量、锁）确保数据一致性和程序正确性。</li></ul><hr><p><strong>特征间的关联性</strong></p><ol><li>并发与共享：<ul><li>并发性使多进程需要共享资源（如CPU时间、内存）；</li><li>共享性支持并发执行的资源需求，二者互为依存。</li></ul></li><li>虚拟与并发&#x2F;共享：<ul><li>虚拟技术通过资源复用支持更高程度的并发和共享（如分页内存管理允许多进程共享物理内存）。</li></ul></li><li>异步性根源：<ul><li>并发和资源竞争直接导致异步，若系统无并发则异步性消失。</li></ul></li></ol><hr><p><strong>实际系统中的应用</strong></p><ul><li>Linux&#x2F;Windows：通过分页和交换分区实现虚拟内存；通过进程调度实现并发。</li><li>实时操作系统：在并发中优先处理紧急任务（如自动驾驶系统），体现共享资源的动态分配策略。</li><li>分布式系统：虚拟化技术扩展为跨节点的资源池（如云计算中的虚拟化集群）。</li></ul><hr><p><strong>总结</strong>：操作系统的四大特征共同支撑了多任务、高效率、高可靠性的运行环境，理解这些特征是掌握其工作原理和优化系统性能的基础。</p><h1 id="4-python和C-的区别"><a href="#4-python和C-的区别" class="headerlink" title="4.python和C++的区别"></a>4.python和C++的区别</h1><p>答：<strong>Python 与 C++ 的核心区别及适用场景对比</strong></p><p>​	Python 和 C++ 是两种设计理念、应用场景和底层机制差异显著的编程语言。以下从多个维度对比两者的核心区别，并结合实际应用场景给出选型建议：</p><hr><p><strong>1. 语言类型与执行方式</strong></p><ul><li><p>Python：</p><ul><li><p>解释型语言：代码逐行解释执行，无需预先编译，可通过直接运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 脚本.py</span><br></pre></td></tr></table></figure></li><li><p>动态类型：变量类型在运行时自动推断，无需显式声明（如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>）。</p></li></ul></li><li><p>C++：</p><ul><li><p>编译型语言：需通过编译器（如 GCC）生成机器码后再执行，编译过程独立于运行阶段。</p></li><li><p>静态类型：变量类型需显式声明（如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>），编译器严格检查类型。</p></li></ul></li></ul><p><strong>典型区别</strong>：Python 灵活但运行时效率较低；C++ 高效但开发周期长，需处理编译错误。</p><hr><p><strong>2. 语法与代码风格</strong></p><ul><li><p>语法复杂度：</p><ul><li><p>Python：语法简洁，强制缩进（如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span>:</span><br></pre></td></tr></table></figure><p>），减少冗余符号，代码可读性高。</p></li><li><p>C++：语法严格，依赖大括号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>和分号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><p>，对格式容错性低（如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (a &gt; 0) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>)。</p></li></ul></li><li><p>代码量对比：</p><ul><li><p>实现相同功能时，Python 代码量通常为 C++ 的 1&#x2F;3~1&#x2F;5。例如，打印 “Hello World” 在 Python 中仅需</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure><p>，而 C++ 需包含头文件、主函数等。</p></li></ul></li></ul><p><strong>典型区别</strong>：Python 适合快速原型开发；C++ 适合需要精细控制的场景。</p><hr><p><strong>3. 内存管理与资源控制</strong></p><ul><li><p>Python：</p><ul><li>自动垃圾回收（GC）：开发者无需手动释放内存，减少内存泄漏风险，但可能因 GC 暂停影响实时性。</li></ul></li><li><p>C++：</p><ul><li><p>手动管理：通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span></span><br></pre></td></tr></table></figure><p>&#x2F;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span></span><br></pre></td></tr></table></figure><p>或智能指针（如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr</span><br></pre></td></tr></table></figure><p>）控制内存，灵活性高但易引发内存泄漏或悬垂指针。</p></li></ul></li></ul><p><strong>典型区别</strong>：Python 简化开发但牺牲控制力；C++ 提供底层控制但学习成本高。</p><hr><p><strong>4. 性能与执行效率</strong></p><ul><li>运行速度：<ul><li>C++：编译为机器码，直接操作硬件，执行效率接近原生性能，适合高频计算（如游戏引擎、实时系统）。</li><li>Python：解释执行，依赖虚拟机（CPython），速度较慢，但可通过 C 扩展（如 NumPy）提升性能。</li></ul></li><li>并发处理：<ul><li>Python：受全局解释器锁（GIL）限制，多线程难以充分利用多核 CPU。</li><li>C++：原生支持多线程、协程，可高效利用多核资源。</li></ul></li></ul><p><strong>典型区别</strong>：C++ 适用于高性能计算；Python 适合 I&#x2F;O 密集型任务。</p><hr><p><strong>5. 应用场景与生态系统</strong></p><ul><li>Python：<ul><li>领域：数据科学（Pandas）、机器学习（TensorFlow）、Web 开发（Django）、自动化脚本。</li><li>库生态：拥有 PyPI 超 30 万第三方库，快速集成功能（如爬虫框架 Scrapy）。</li></ul></li><li>C++：<ul><li>领域：操作系统、游戏引擎（Unreal）、嵌入式系统、高频交易。</li><li>库生态：标准库（STL）提供基础数据结构，依赖 Boost、Qt 等扩展库。</li></ul></li></ul><p><strong>典型区别</strong>：Python 侧重快速开发与高层抽象；C++ 专注底层控制与性能优化。</p><hr><p><strong>6. 学习曲线与适用人群</strong></p><ul><li>Python：<ul><li>新手友好：语法简单，社区资源丰富（如教程、Stack Overflow），适合零基础入门。</li><li>推荐人群：数据科学家、Web 开发者、自动化测试工程师。</li></ul></li><li>C++：<ul><li>进阶挑战：需掌握指针、内存管理、多态等复杂概念，适合有编程基础者。</li><li>推荐人群：系统工程师、游戏开发者、硬件编程人员。</li></ul></li></ul><p><strong>典型区别</strong>：Python 适合快速验证想法；C++ 适合深入理解计算机原理。</p><hr><p><strong>总结与选型建议</strong></p><table><thead><tr><th><strong>维度</strong></th><th><strong>Python</strong></th><th><strong>C++</strong></th></tr></thead><tbody><tr><td><strong>核心优势</strong></td><td>开发效率高、生态丰富</td><td>性能极致、底层控制灵活</td></tr><tr><td><strong>适用场景</strong></td><td>数据分析、AI、脚本自动化</td><td>游戏引擎、实时系统、嵌入式开发</td></tr><tr><td><strong>学习难度</strong></td><td>低（适合新手）</td><td>高（需编程基础）</td></tr><tr><td><strong>协作模式</strong></td><td>可通过 C 扩展提升性能 4</td><td>可嵌入 Python 作为底层模块 4</td></tr></tbody></table><p><strong>选型策略</strong>：</p><ul><li><strong>短期项目&#x2F;快速验证</strong>：优先 Python。</li><li><strong>长期维护&#x2F;性能敏感</strong>：选择 C++。</li><li>混合开发：用 C++ 实现性能关键模块，Python 集成上层逻辑。</li></ul><h1 id="5-谈谈对堆排序的理解"><a href="#5-谈谈对堆排序的理解" class="headerlink" title="5.谈谈对堆排序的理解"></a>5.谈谈对堆排序的理解</h1><p>答：堆排序（Heap Sort）是一种基于堆数据结构的经典排序算法，结合了<strong>完全二叉树</strong>的结构特性和<strong>原地排序</strong>的高效性。以下从算法原理、实现步骤、复杂度分析及优缺点等角度展开论述：</p><hr><p>一、算法原理与核心思想</p><ol><li><strong>堆数据结构</strong><ul><li>堆是一种完全二叉树，分为大顶堆（父节点值≥子节点）和小顶堆（父节点值≤子节点）。</li><li>堆性质维护：通过调整节点位置，确保每个子树满足堆的定义，从而保证根节点为最大值（大顶堆）或最小值（小顶堆）。</li></ul></li><li><strong>排序逻辑</strong><ul><li>两步核心操作：<ol><li>构建堆：将无序数组转换为堆结构（通常升序用大顶堆，降序用小顶堆）。</li><li>交换与调整：将堆顶元素（最大值&#x2F;最小值）与数组末尾元素交换，缩小堆范围后重新调整剩余元素为堆，直至完成排序。</li></ol></li></ul></li></ol><hr><p>二、实现步骤详解</p><ol><li><strong>构建初始堆</strong><ul><li>从最后一个非叶子节点（索引为 n&#x2F;2-1）开始，自底向上调整子树为堆。</li><li>调整方法（以最大堆为例）：<ul><li>若父节点小于子节点，交换父子位置，并递归向下调整受影响的子树。</li></ul></li></ul></li><li><strong>排序阶段</strong><ul><li>交换堆顶与当前未排序部分的末尾元素，将最大值固定到数组末尾。</li><li>缩小堆范围，重新调整剩余元素为堆，重复此过程直至排序完成。</li></ul></li></ol><p><strong>示例</strong>：<br>若数组为 <code>[3, 1, 6, 5, 2]</code>，构建大顶堆后堆顶为6，交换6与末尾元素2，得到 <code>[2, 1, 3, 5 | 6]</code>，再对前4个元素重新调整堆 。</p><hr><p>三、时间与空间复杂度</p><ol><li><strong>时间复杂度</strong><ul><li>平均与最坏情况：均为O(n log n)。<ul><li>构建堆的时间复杂度为 O(n)（通过数学公式推导）。</li><li>每次调整堆需 O(log n)，共执行 n-1 次，总复杂度为 O(n log n)。</li></ul></li></ul></li><li><strong>空间复杂度</strong><ul><li>原地排序：仅需常数级额外空间（O(1)），无需依赖外部存储。</li></ul></li></ol><hr><p>四、优缺点分析</p><ol><li><strong>优点</strong><ul><li>高效稳定：时间复杂度稳定为 O(n log n)，适合大规模数据排序。</li><li>内存友好：原地排序，适用于内存受限场景（如嵌入式系统）。</li><li>无需递归：相比快速排序，避免递归栈溢出风险。</li></ul></li><li><strong>缺点</strong><ul><li>不稳定排序：相等元素可能因堆调整改变相对顺序（例如<code>[77a, 45, 77b]</code>排序后可能变为<code>[45, 77b, 77a]</code>）。</li><li>常数项较高：数据量较小时，堆调整的常数开销可能高于插入排序或快速排序。</li><li>实现复杂度：需理解堆的构建与调整逻辑，代码实现相对复杂。</li></ul></li></ol><hr><p>五、应用场景</p><ol><li>大规模数据排序<ul><li>内存有限时，堆排序的原地特性优于归并排序。</li></ul></li><li>实时系统<ul><li>时间复杂度的稳定性使其适合对响应时间要求严格的场景（如高频交易系统）。</li></ul></li><li>优先队列实现<ul><li>堆结构天然支持动态插入与快速提取极值，常用于任务调度（如操作系统进程调度）。</li></ul></li></ol><hr><p>六、与其他排序算法对比</p><table><thead><tr><th><strong>算法</strong></th><th><strong>平均时间复杂度</strong></th><th><strong>空间复杂度</strong></th><th><strong>稳定性</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong>堆排序</strong></td><td>O(n log n)</td><td>O(1)</td><td>不稳定</td><td>大规模数据、内存受限</td></tr><tr><td>快速排序</td><td>O(n log n)</td><td>O(log n)</td><td>不稳定</td><td>通用场景、数据随机分布</td></tr><tr><td>归并排序</td><td>O(n log n)</td><td>O(n)</td><td>稳定</td><td>外部排序、稳定性要求高</td></tr></tbody></table><hr><p><strong>总结</strong></p><p>​	堆排序通过巧妙利用堆数据结构，在时间与空间效率之间取得平衡，尤其适合处理大规模数据集和内存敏感场景。尽管存在稳定性不足和实现复杂度较高的缺点，但其理论价值和实际应用（如优先队列、实时系统）使其在算法领域占据重要地位。</p><h1 id="6-链表排序"><a href="#6-链表排序" class="headerlink" title="6.链表排序"></a>6.链表排序</h1><p>答：链表排序算法详解</p><p>链表排序是数据结构中的经典问题，其核心挑战在于链表的非连续存储特性导致无法像数组一样直接通过下标高效访问。以下是链表排序的主要方法及其实现原理、复杂度分析与适用场景，结合多篇技术资料整理而成：</p><hr><p>一、插入排序（Insertion Sort）</p><p><strong>实现原理</strong>：</p><ul><li>从链表头开始遍历，将当前节点插入到已排序部分的正确位置。</li><li>维护一个虚拟头节点（dummy node）简化插入操作，避免频繁处理头节点变化。</li></ul><p><strong>代码要点</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CppListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; ) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy, next = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt;= p-&gt;val) cur = cur-&gt;next;</span><br><span class="line">        p-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = p;</span><br><span class="line">        p = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度</strong>：</p><ul><li>时间复杂度：O(n²)，适用于小规模数据或接近有序的链表。</li><li>空间复杂度：O(1)，原地排序。</li></ul><p><strong>适用场景</strong>：</p><ul><li>数据规模较小（如节点数 &lt; 1000）。</li><li>链表基本有序时性能接近线性时间。</li></ul><hr><p>二、归并排序（Merge Sort）</p><p><strong>实现原理</strong>：</p><ol><li><strong>自顶向下递归法</strong>：<ul><li>快慢指针找到链表中点，分割为两个子链表递归排序，再合并有序链表。</li><li>合并操作类似合并两个有序链表（LeetCode 21题）。</li></ul></li><li><strong>自底向上迭代法</strong>：<ul><li>按长度分割链表（如1, 2, 4…），逐层合并相邻子链表，避免递归栈空间。</li></ul></li></ol><p><strong>代码要点</strong>（自底向上）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CppListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt; n; len *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j += <span class="number">2</span> * len) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p = head, q = head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; q; i++) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">auto</span> o = q;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; o; i++) o = o-&gt;next;</span><br><span class="line">            <span class="comment">// 合并p和q指向的两个子链表</span></span><br><span class="line">            <span class="comment">// ...（具体合并逻辑）</span></span><br><span class="line">            head = o;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        head = dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度</strong>：</p><ul><li>时间复杂度：O(n log n)，稳定高效，适合大规模数据。</li><li>空间复杂度：递归法O(log n)（栈空间），迭代法O(1)。</li></ul><p><strong>适用场景</strong>：</p><ul><li>大规模无序链表排序的首选算法。</li><li>需要稳定排序时优先考虑。</li></ul><hr><p>三、快速排序（Quick Sort）</p><p><strong>实现原理</strong>：</p><ul><li>选择头节点为基准，将链表分为小于基准和大于基准的两部分，递归排序后合并。</li><li>分区操作需遍历链表，通过指针维护两个子链表（<code>less</code>和<code>greater</code>）。</li></ul><p><strong>代码要点</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Cppvoid <span class="title">QuicklySort</span><span class="params">(ListNode* L, ListNode* R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R || L-&gt;next == R) <span class="keyword">return</span>;</span><br><span class="line">    ListNode *P = L, *pi = L, *pj = L;</span><br><span class="line">    ListNode *i = pi-&gt;next, *j = pj-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (j != R) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j-&gt;val &lt; P-&gt;val) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(i-&gt;val, j-&gt;val);</span><br><span class="line">            pi = i; i = i-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pj = j; j = j-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(pi-&gt;val, P-&gt;val);</span><br><span class="line">    <span class="built_in">QuicklySort</span>(L, pi);</span><br><span class="line">    <span class="built_in">QuicklySort</span>(i, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度</strong>：</p><ul><li>时间复杂度：平均O(n log n)，最坏O(n²)（链表已有序时）。</li><li>空间复杂度：O(log n)（递归栈）。</li></ul><p><strong>适用场景</strong>：</p><ul><li>数据随机分布时性能接近归并排序。</li><li>对内存敏感但允许平均时间复杂度较高的情况。</li></ul><hr><p>四、选择排序（Selection Sort）</p><p><strong>实现原理</strong>：</p><ul><li>遍历链表找到最小节点，将其移动到已排序部分的末尾，重复直到链表完全有序。</li><li>需维护指针记录当前最小节点的前驱以完成节点交换。</li></ul><p><strong>复杂度</strong>：</p><ul><li>时间复杂度：O(n²)，性能较差但实现简单。</li><li>空间复杂度：O(1)。</li></ul><p><strong>适用场景</strong>：</p><ul><li>教学示例或小规模数据。</li><li>需要减少写操作（如闪存存储）的场景。</li></ul><hr><p>五、其他优化技巧</p><ol><li><strong>数组辅助排序</strong>：<ul><li>将链表数据复制到数组，排序后重建链表。时间复杂度O(n log n)，但需额外O(n)空间。</li><li>适用于对空间不敏感但对时间要求严格的场景。</li></ul></li><li><strong>冒泡排序</strong>：<ul><li>通过相邻节点比较交换实现排序，时间复杂度O(n²)，实现简单但效率低。</li></ul></li><li><strong>优化指针操作</strong>：<ul><li>减少节点交换次数（如仅交换数据域），或使用尾指针加速遍历。</li></ul></li></ol><hr><p>六、算法对比与选型建议</p><table><thead><tr><th><strong>算法</strong></th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>插入排序</strong></td><td>O(n²)</td><td>O(1)</td><td>稳定</td><td>小数据量或接近有序</td></tr><tr><td><strong>归并排序</strong></td><td>O(n log n)</td><td>O(1)或O(log n)</td><td>稳定</td><td>大规模数据、稳定性要求</td></tr><tr><td><strong>快速排序</strong></td><td>O(n log n)~O(n²)</td><td>O(log n)</td><td>不稳定</td><td>数据随机分布</td></tr><tr><td><strong>选择排序</strong></td><td>O(n²)</td><td>O(1)</td><td>不稳定</td><td>教学或小数据量</td></tr></tbody></table><p><strong>选型策略</strong>：</p><ul><li><strong>优先归并排序</strong>：处理大规模数据或需稳定排序时。</li><li><strong>快速排序&#x2F;插入排序</strong>：数据随机分布或规模较小时。</li><li><strong>避免冒泡&#x2F;选择排序</strong>：除非数据量极小或特殊需求。</li></ul><hr><p>七、实例与注意事项</p><ol><li>链表节点交换：<ul><li>直接交换节点需处理前后指针关系，易出错；可改为交换数据域简化操作。</li></ul></li><li>递归深度限制：<ul><li>递归实现的归并排序或快速排序可能因栈溢出导致问题，优先选择迭代法。</li></ul></li><li>稳定性影响：<ul><li>若业务依赖相等元素的原始顺序，需选择稳定算法（如归并排序）。</li></ul></li></ol><p>​	通过综合应用上述方法，可根据实际场景高效解决链表排序问题。</p><h1 id="7-PCM是什么"><a href="#7-PCM是什么" class="headerlink" title="7.PCM是什么"></a>7.PCM是什么</h1><p>答：PCM（Pulse-Code Modulation，脉冲编码调制）是一种广泛应用于多领域的信号处理技术或系统模块，其具体定义和功能根据应用场景的不同而有所差异。以下是其在不同领域中的核心解释：</p><hr><p>一、音频与通信领域的PCM</p><p>​	PCM是<strong>将模拟信号转换为数字信号的标准方法</strong>，通过三个步骤实现：</p><ol><li>采样（Sampling）：以固定时间间隔采集模拟信号的振幅值。例如，CD音质的采样率为44.1kHz，即每秒采样44,100次。</li><li>量化（Quantization）：将采样后的连续振幅值离散化为有限个等级。量化位深（如16-bit、24-bit）决定精度，位深越高，声音还原度越佳。</li><li>编码（Coding）：将量化后的数值转换为二进制数据流，形成PCM数据。例如，FFmpeg中常见的<code>s16le</code>格式表示有符号16位小端存储的PCM数据。</li></ol><p><strong>技术指标</strong>：</p><ul><li>采样率：如通话常用8kHz，蓝光音频高达192kHz。</li><li>声道数：支持单声道（Mono）、立体声（Stereo）及5.1环绕声。</li><li>字节序：小端存储（如<code>s16le</code>）更高效。</li></ul><p><strong>应用场景</strong>：</p><ul><li>音频文件存储（如WAV格式）。</li><li>通信系统（如蓝牙语音传输、电话信号数字化）。</li></ul><hr><p>二、汽车电子领域的PCM</p><p>​	在汽车中，PCM指<strong>动力系统控制模块</strong>（Powertrain Control Module），是发动机管理的核心：</p><ol><li>核心功能：<ul><li>控制燃油喷射量、点火时机、节气门开度。</li><li>监测传感器数据（如温度、进气压力），动态调整发动机参数。</li></ul></li><li>技术特性：<ul><li>与ECU（发动机控制模块）协同工作，处理实时数据。</li><li>支持故障诊断，存储故障代码并通过指示灯提示。</li></ul></li></ol><p><strong>实际应用</strong>：</p><ul><li>优化燃油经济性和排放控制。</li><li>在混合动力车中协调电机与发动机的协同工作。</li></ul><hr><p>三、工业与硬件领域的PCM</p><ol><li><p>硬件接口：</p><ul><li>PCM接口用于AP处理器与通信模块（如蓝牙、MODEM）间的语音数据传输，包含4根信号线（CLK、SYNC、IN、OUT）。</li><li>采用时分复用（TDM）技术，支持多声道数据传输（如8声道×32bit的TDM256模式）。</li></ul></li><li><p>工业控制：</p><ul><li><p>输入输出指令（如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">in</span><br></pre></td></tr></table></figure><p>读取传感器信号、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out</span><br></pre></td></tr></table></figure><p>控制执行器）。</p></li><li><p>故障诊断方法包括自环检测、告警灯分析和误码仪测试。</p></li></ul></li></ol><hr><p>四、总结：PCM的多义性</p><table><thead><tr><th><strong>领域</strong></th><th><strong>定义</strong></th><th><strong>核心作用</strong></th></tr></thead><tbody><tr><td><strong>音频&#x2F;通信</strong></td><td>模拟信号数字化的编码方法</td><td>实现高保真音频存储与传输 1 4</td></tr><tr><td><strong>汽车电子</strong></td><td>发动机控制模块</td><td>优化动力系统性能与可靠性 2</td></tr><tr><td><strong>工业硬件</strong></td><td>数据传输接口或控制指令系统</td><td>支持多设备通信与自动化控制 3 5</td></tr></tbody></table><p><strong>注意</strong>：在不同上下文中，PCM的具体含义需结合应用场景判断。例如，音频工程师讨论PCM时通常指编码技术，而汽车工程师则指发动机控制模块。</p><h1 id="8-如何避免死锁状态。"><a href="#8-如何避免死锁状态。" class="headerlink" title="8.如何避免死锁状态。"></a>8.如何避免死锁状态。</h1><p>答：死锁是多个进程或线程因竞争资源陷入相互等待的僵局状态，其发生需满足<strong>互斥、请求与保持、不可剥夺、循环等待</strong>四个必要条件。避免死锁的核心思路是通过设计策略破坏其中一个或多个条件，并结合动态检测与工程优化手段。以下是具体方法及实践建议：</p><hr><p>一、破坏死锁的必要条件</p><ol><li><strong>破坏循环等待</strong><ul><li>资源有序分配法：为所有资源赋予全局唯一编号，强制进程按编号递增顺序申请资源，释放时按逆序操作。例如，若进程需同时申请资源A（编号1）和B（编号2），必须按A→B顺序请求，避免循环依赖。</li><li>统一锁顺序：在多线程编程中，定义锁的获取顺序，所有线程必须按此顺序加锁。例如，线程A和B都需锁L1和L2时，统一要求先获取L1再L2。</li></ul></li><li><strong>破坏请求与保持</strong><ul><li>一次性分配所有资源：进程在启动时申请其所需的全部资源，若无法满足则阻塞等待。例如，数据库事务中预先锁定所有涉及的数据行。</li><li>动态释放资源：若进程在申请新资源时被拒绝，需主动释放已持有的部分资源，避免长期占用。</li></ul></li><li><strong>破坏不可剥夺</strong><ul><li>资源抢占：允许系统强制回收已分配的资源（如内存、CPU），但需谨慎设计抢占后的恢复机制，避免数据不一致。</li></ul></li></ol><hr><p>二、动态避免死锁</p><ol><li><strong>银行家算法（Banker’s Algorithm）</strong><ul><li>在资源分配前预判安全性，仅允许分配后系统仍处于安全状态（存在至少一个安全执行序列）。例如，进程需提前声明最大资源需求，系统动态计算剩余资源是否满足后续进程需求。</li><li>安全状态判定：若剩余资源可满足某一进程的最大需求，则分配资源并标记其执行完成，递归检查后续进程直至所有进程均可完成。</li></ul></li><li><strong>超时与重试机制</strong><ul><li>设置资源请求的超时时间（如500ms），超时后释放已持有资源并重试，避免永久阻塞。</li><li>应用场景：分布式系统中通过超时中断事务，回滚并重试。</li></ul></li></ol><hr><p>三、工程实践中的优化策略</p><ol><li><strong>减少锁的竞争</strong><ul><li>缩小锁粒度：将大锁拆分为多个细粒度锁，减少并发冲突。例如，ConcurrentHashMap采用分段锁。</li><li>读写锁分离：读操作用共享锁，写操作用独占锁，提升并发性能（如Java的ReentrantReadWriteLock）。</li></ul></li><li><strong>事务与并发控制</strong><ul><li>拆分长事务：将耗时事务分解为多个短事务，降低锁持有时间。例如，电商订单处理中，拆分库存扣减与支付操作为独立事务。</li><li>异步处理：通过消息队列（如Kafka）异步执行非关键操作，减少同步阻塞。</li></ul></li><li><strong>死锁检测与恢复</strong><ul><li>定期检测：运行死锁检测算法（如资源分配图检测），发现死锁后强制终止代价最小的进程或回滚事务。</li><li>工具辅助：使用JConsole、VisualVM等工具监控线程状态，结合日志分析死锁位置。</li></ul></li></ol><hr><p>四、总结与选型建议</p><table><thead><tr><th><strong>策略类型</strong></th><th><strong>适用场景</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>破坏必要条件</strong></td><td>系统设计初期，资源类型明确（如嵌入式系统）</td><td>实现简单，但可能限制灵活性</td></tr><tr><td><strong>动态避免（银行家算法）</strong></td><td>资源需求可预知的系统（如数据库管理）</td><td>安全性高，但计算开销大</td></tr><tr><td><strong>工程优化</strong></td><td>高并发、分布式系统（如互联网应用）</td><td>需结合具体业务逻辑设计</td></tr></tbody></table><p><strong>最佳实践</strong>：</p><ol><li>多策略结合：例如，使用资源有序分配预防死锁，同时引入超时机制动态恢复。</li><li>性能与安全权衡：对实时性要求高的系统优先破坏循环等待；对数据一致性要求高的系统采用银行家算法。</li><li>测试与监控：通过压力测试模拟死锁场景，结合APM工具（如Prometheus）实时监控资源竞争。</li></ol><p>​	通过上述方法，可显著降低死锁发生概率，但需根据实际场景灵活调整策略，并在系统设计阶段充分考虑资源管理逻辑。</p><h1 id="9-欧拉公式"><a href="#9-欧拉公式" class="headerlink" title="9.欧拉公式"></a>9.欧拉公式</h1><p>答：<strong>离散数学中的欧拉公式详解</strong></p><p><strong>1. 公式定义与基本形式</strong></p><p>离散数学中的欧拉公式主要应用于<strong>图论</strong>领域，描述连通平面图的顶点、边与面之间的数量关系。其核心形式为：<code>𝑛−𝑚+𝑟=2</code>。</p><ul><li>参数：<ul><li><em>n</em>：图的顶点数（Vertices）。</li><li><em>m</em>：图的边数（Edges）。</li><li><em>r</em>：图的面数（Faces），包括无限外部面。</li></ul></li><li>适用条件：仅适用于连通的平面图（即可以画在平面上且边不相交的图）。</li></ul><p><strong>扩展形式</strong>：若平面图包含 <em>k</em> 个连通分支（即由多个不连通的子图组成），则公式修正为：<code>𝑛−𝑚+𝑟=𝑘+1</code>，此形式适用于非连通的平面图。</p><hr><p><strong>2. 定理与推论</strong></p><ol><li><p>面次数定理：平面图中所有面的次数之和等于边数的两倍。例如，若图中有<em>m</em>条边，则所有面的次数总和为2<em>m</em>。</p></li><li><p>极大平面图性质：对于<code>*n≥3*</code>阶的简单连通极大平面图（无法再添加边而不破坏平面性），边数满足：<code>𝑚=3𝑛−6</code>，这一结论常用于判断图的平面性。</p></li><li><p>简单平面图的边数限制：若每个面的次数至少为<em>l</em>（通常<code>l≥3</code>），则边数 <em>m</em>与顶点数<em>n</em>满足：</p><p><code>𝑚≤𝑙*(𝑛−2)/(𝑙−2)</code>特别地，当<code>𝑙=3</code>时，简化为<code>𝑚≤3𝑛−6</code>。</p></li></ol><hr><p><strong>3. 应用场景</strong></p><ol><li><strong>平面图判定</strong>：<ul><li>通过验证 𝑛−𝑚+𝑟&#x3D;2<em>n</em>−<em>m</em>+<em>r</em>&#x3D;2 是否成立，辅助判断图是否为平面图。</li><li>结合库拉托夫斯基定理（Kuratowski定理），排除包含<em>𝐾5</em>或<em>K3,3</em>同胚子图的非平面图。</li></ul></li><li><strong>多面体定理</strong>：<ul><li>欧拉公式最初来源于凸多面体的顶点、棱和面的关系，例如立方体满足<code>8-12+6=2</code>。</li><li>推广到高维拓扑学中，用于计算多面体的欧拉示性数。</li></ul></li><li><strong>网络设计与电路分析</strong>：<ul><li>在电路板布线中，利用欧拉公式优化连通性并减少交叉点。</li><li>分析平面图的连通分支数，评估通信网络的冗余性。</li></ul></li></ol><hr><p><strong>4. 扩展与关联概念</strong></p><ol><li><strong>对偶图</strong>：<ul><li>平面图<em>G</em>的对偶图∗<em>G</em>∗满足<code>n∗=r，𝑚∗=m，𝑟∗=𝑛</code>，其中<em>n</em>、<em>m</em>、<em>r</em> 分别为对偶图的顶点、边和面数。</li><li>应用示例：地图着色问题中，四色定理的证明依赖于对偶图的性质。</li></ul></li><li><strong>欧拉路径与回路</strong>：<ul><li>欧拉回路：通过图中所有边一次的闭合路径，存在条件为图是连通的且所有顶点度数为偶。</li><li>半欧拉图：存在欧拉通路但无回路，恰有两个顶点度数为奇。</li></ul></li><li><strong>哈密顿图对比</strong>：<ul><li>欧拉公式关注边的遍历，而哈密顿图要求遍历所有顶点。两者在判定条件与应用场景上存在显著差异。</li></ul></li></ol><hr><p><strong>5. 学习与理解技巧</strong></p><ol><li>几何直观：通过绘制简单平面图（如四面体、立方体）验证公式，增强对顶点、边、面关系的理解。</li><li>结合实例：分析非平面图（如<em>K5</em>）为何不满足<code>𝑛−𝑚+𝑟=2</code>，理解公式的边界条件。</li><li>公式推导：从连通图的树结构出发（树满足<code>𝑛=𝑚+1</code>），逐步添加边并观察面数的变化，推导欧拉公式。</li></ol><hr><p><strong>总结</strong></p><p>​	离散数学中的欧拉公式是图论与拓扑学的核心工具，其简洁形式揭示了平面图结构的深层规律。掌握该公式需结合几何直观、定理推论及实际应用场景（如网络设计、多面体分析）。通过对比欧拉路径与哈密顿路径，可进一步深化对图遍历问题的理解。</p><h1 id="10-自动机和有限自动机的区别"><a href="#10-自动机和有限自动机的区别" class="headerlink" title="10.自动机和有限自动机的区别"></a>10.自动机和有限自动机的区别</h1><p>答：<strong>自动机与有限自动机的区别详解</strong></p><p>​	自动机（Automaton）与有限自动机（Finite Automaton）是计算理论中的核心概念，两者的区别主要体现在<strong>定义范围、结构复杂性、计算能力</strong>等方面。以下从多维度对比分析：</p><hr><p><strong>1. 定义范围</strong></p><ul><li><p>自动机：广义的自动机是描述计算过程的数学模型，涵盖多种类型，包括有限自动机、下推自动机（PDA）、线性有界自动机（LBA）、图灵机（TM）等。其核心是通过状态转移对输入符号序列进行处理。</p></li><li><p>有限自动机：是自动机的一种特例，仅包含有限状态和有限输入字母表，无额外存储结构（如堆栈或磁带）。其定义形式化为五元组<code>𝑀=(𝑄,Σ,𝛿,𝑞0,𝐹)</code></p><p>，其中<em>Q</em>为状态集合，Σ为输入符号集。</p></li></ul><hr><p><strong>2. 结构与能力</strong></p><table><thead><tr><th><strong>维度</strong></th><th><strong>有限自动机</strong></th><th><strong>其他自动机（如PDA、图灵机）</strong></th></tr></thead><tbody><tr><td><strong>存储结构</strong></td><td>无额外存储，仅依赖有限状态和输入符号。</td><td>可能包含堆栈（PDA）、无限磁带（图灵机）等 2 7。</td></tr><tr><td><strong>状态转移</strong></td><td>状态转移仅由当前状态和输入符号决定（确定性DFA或非确定性NFA）。</td><td>可依赖存储内容（如堆栈顶符号）决定转移 2。</td></tr><tr><td><strong>语言识别能力</strong></td><td>仅能识别<strong>正则语言</strong>（Type-3文法），例如简单的模式匹配（如电话号码格式）。</td><td>PDA识别<strong>上下文无关语言</strong>（Type-2文法），图灵机识别递归可枚举语言 2 4。</td></tr></tbody></table><hr><p><strong>3. 具体类型对比</strong></p><ol><li><strong>有限自动机（FA）</strong><ul><li>确定性（DFA）：每个状态对同一输入符号有唯一转移路径，状态转换函数为单值映射。</li><li>非确定性（NFA）：同一输入符号可转移到多个状态，但可通过子集构造法转换为等价的DFA。</li><li>应用场景：编译器词法分析（识别关键字、标识符）、简单控制逻辑（如自动售货机状态管理）。</li></ul></li><li><strong>下推自动机（PDA）</strong><ul><li><strong>特点</strong>：增加堆栈存储，可处理嵌套结构（如括号匹配）。</li><li>能力：识别上下文无关语言，例如编程语言的语法解析。</li></ul></li><li><strong>图灵机（TM）</strong><ul><li><strong>特点</strong>：拥有无限长的磁带，支持读写和移动操作。</li><li>能力：理论上可模拟任何算法，是计算能力的上限。</li></ul></li></ol><hr><p><strong>4. 核心差异总结</strong></p><table><thead><tr><th><strong>特征</strong></th><th><strong>有限自动机</strong></th><th><strong>广义自动机（如PDA、TM）</strong></th></tr></thead><tbody><tr><td><strong>状态数量</strong></td><td>有限</td><td>有限（PDA）或无限（TM）</td></tr><tr><td><strong>存储机制</strong></td><td>无</td><td>堆栈（PDA）、磁带（TM）</td></tr><tr><td><strong>语言类</strong></td><td>正则语言（Type-3）</td><td>上下文无关（Type-2）或递归可枚举（Type-0）</td></tr><tr><td><strong>复杂度</strong></td><td>低，适用于简单模式匹配</td><td>高，可处理复杂逻辑（如语法解析、通用计算）</td></tr></tbody></table><hr><p><strong>5. 实际应用示例</strong></p><ul><li>有限自动机：<ul><li>编译器词法分析：识别代码中的关键字（如<code>if</code>，<code>while</code>）和标识符。</li><li>硬件设计：实现数字电路的状态控制（如交通灯时序逻辑）。</li></ul></li><li>下推自动机：<ul><li>语法分析：解析编程语言中的嵌套结构（如函数调用、表达式求值）。</li></ul></li><li>图灵机：<ul><li>通用计算模型：理论研究中的计算能力基准，描述算法可解性问题。</li></ul></li></ul><hr><p><strong>总结</strong></p><p>​	自动机是计算理论的广义模型，而有限自动机是其最基础的形式，仅依赖有限状态和输入符号，无额外存储。两者的核心区别在于<strong>存储机制</strong>和<strong>语言识别能力</strong>：</p><ul><li>有限自动机适用于简单、线性的模式匹配（正则语言）。</li><li>更复杂的自动机（如PDA、图灵机）通过扩展存储结构，可处理嵌套、递归等复杂逻辑。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yishuangrenew.github.io">C x l</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yishuangrenew.github.io/2025/02/27/touchstone_20250227/">https://yishuangrenew.github.io/2025/02/27/touchstone_20250227/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yishuangrenew.github.io" target="_blank">趁年轻</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94%E5%A4%8D%E8%AF%95/">考研复试</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">C x l</div><div class="author-info-description">低语中果决，成功时清醒</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yishuangrenew"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yishuangrenew" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎进行算法、技术交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">1.介绍操作系统的存储管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-MYSQL%E5%92%8Credis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">2.MYSQL和redis的应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">3.</span> <span class="toc-text">3.操作系统的特征</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-python%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">4.python和C++的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E8%B0%88%E8%B0%88%E5%AF%B9%E5%A0%86%E6%8E%92%E5%BA%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">5.谈谈对堆排序的理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">6.链表排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-PCM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.</span> <span class="toc-text">7.PCM是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">8.</span> <span class="toc-text">8.如何避免死锁状态。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">9.欧拉公式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%92%8C%E6%9C%89%E9%99%90%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">10.自动机和有限自动机的区别</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/28/CCF%20CSP/%E3%80%90CCF%20CSP-20131201%E3%80%91%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E6%95%B0/" title="【CCF CSP-20131201】出现次数最多的数">【CCF CSP-20131201】出现次数最多的数</a><time datetime="2025-02-27T16:00:00.000Z" title="发表于 2025-02-28 00:00:00">2025-02-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/touchstone_20250227/" title="touchstone_2025/02/27">touchstone_2025/02/27</a><time datetime="2025-02-26T16:00:00.000Z" title="发表于 2025-02-27 00:00:00">2025-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/07/2025-2-7-01/" title="2025/2/7-01">2025/2/7-01</a><time datetime="2025-02-07T14:25:52.000Z" title="发表于 2025-02-07 22:25:52">2025-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/06/hello-world/" title="Hello World 2025年2月7日18:05:38"><img src="/img/background.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Hello World 2025年2月7日18:05:38"></a><div class="content"><a class="title" href="/2025/02/06/hello-world/" title="Hello World 2025年2月7日18:05:38">Hello World 2025年2月7日18:05:38</a><time datetime="2025-02-06T12:25:23.676Z" title="发表于 2025-02-06 20:25:23">2025-02-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/07/markdown_notes/" title="markdown_notes">markdown_notes</a><time datetime="2022-09-06T16:00:00.000Z" title="发表于 2022-09-07 00:00:00">2022-09-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By C x l</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="772394587" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrctype="-1"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>